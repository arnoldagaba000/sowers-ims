generator client {
  provider        = "prisma-client"
  output          = "../src/generated/prisma"
  moduleFormat    = "esm"
  runtime         = "bun"
  previewFeatures = ["fullTextSearchPostgres"]
}

datasource db {
  provider = "postgresql"
}

// ============================================================================
// USER MANAGEMENT (Prepared for Phase 4 - Auth)
// ============================================================================

// USER
// Prepared for Better Auth integration
// Schema ready but not actively used until auth is implemented
model User {
  id            String  @id
  name          String
  email         String
  emailVerified Boolean @default(false)
  image         String?

  // Role-based access control (prepare for future)
  role UserRole @default(USER)

  // Audit fields
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime?

  sessions Session[]
  accounts Account[]

  @@unique([email])
  @@map("user")
}

enum UserRole {
  ADMIN // Full system access
  MANAGER // Location/regional management
  USER // Standard user
  VIEWER // Read-only access
}

model Session {
  id        String   @id
  expiresAt DateTime
  token     String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  ipAddress String?
  userAgent String?
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([token])
  @@index([userId])
  @@map("session")
}

model Account {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  @@index([userId])
  @@map("account")
}

model Verification {
  id         String   @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([identifier])
  @@map("verification")
}

// ============================================================================
// CORE DOMAIN ENTITIES
// ============================================================================

// CATEGORY
// Hierarchical product categorization supporting nested categories
// Soft delete enabled - categories with products cannot be hard deleted
model Category {
  id          String  @id @default(cuid())
  name        String
  description String?
  slug        String  @unique

  // Hierarchical support for nested categories (e.g., Electronics > Computers > Laptops)
  parentId String?
  parent   Category?  @relation("CategoryHierarchy", fields: [parentId], references: [id], onDelete: Restrict)
  children Category[] @relation("CategoryHierarchy")

  // Relationships
  products Product[]

  // Audit fields
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime?

  // Indexes for performance
  @@index([slug])
  @@index([parentId])
  @@index([deletedAt]) // Efficiently filter soft-deleted records
  @@map("categories")
}

// SUPPLIER
// External entities that supply products
// Many-to-many with Product (a product can have multiple suppliers)
model Supplier {
  id   String @id @default(cuid())
  name String
  code String @unique // Business-friendly identifier (e.g., "SUP-001")

  // Contact information
  contactName String?
  email       String?
  phone       String?

  // Address
  addressLine1 String?
  addressLine2 String?
  city         String?
  state        String?
  postalCode   String?
  country      String?

  // Business details
  taxId        String?
  paymentTerms String? // e.g., "Net 30", "Net 60"
  notes        String?

  // Status
  isActive Boolean @default(true)

  // Relationships
  productSuppliers ProductSupplier[]
  purchaseOrders   PurchaseOrder[]

  // Audit fields
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime?

  @@index([code])
  @@index([isActive])
  @@index([deletedAt])
  @@map("suppliers")
}

// LOCATION
// Physical locations/warehouses where inventory is stored
// Multi-location support is foundational to the system
model Location {
  id   String @id @default(cuid())
  name String
  code String @unique // Business-friendly identifier (e.g., "WH-NYC", "STORE-LA")

  // Location type for business logic (warehouse, store, distribution center, etc.)
  locationType LocationType @default(WAREHOUSE)

  // Address
  addressLine1 String?
  addressLine2 String?
  city         String?
  state        String?
  postalCode   String?
  country      String?

  // Operational details
  isActive  Boolean @default(true)
  managerId String? // Future: link to User when auth is added

  // Relationships
  inventory      Inventory[]
  movementsFrom  InventoryMovement[] @relation("MovementFromLocation")
  movementsTo    InventoryMovement[] @relation("MovementToLocation")
  purchaseOrders PurchaseOrder[]

  // Audit fields
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime?

  @@index([code])
  @@index([isActive])
  @@index([locationType])
  @@index([deletedAt])
  @@map("locations")
}

enum LocationType {
  WAREHOUSE
  STORE
  DISTRIBUTION_CENTER
  SHOWROOM
  VIRTUAL // For digital/virtual inventory
}

// PRODUCT
// Core entity representing items in inventory
// Designed for flexibility: can represent physical goods, services, or assemblies
model Product {
  id String @id @default(cuid())

  // Basic information
  name        String
  sku         String  @unique // Stock Keeping Unit - unique business identifier
  barcode     String? @unique // UPC/EAN barcode
  description String?

  // Categorization
  categoryId String?
  category   Category? @relation(fields: [categoryId], references: [id], onDelete: SetNull)

  // Pricing
  costPrice    Int? // Cost from supplier
  sellingPrice Int? // Default selling price

  // Physical attributes
  weight     Decimal? @db.Decimal(10, 2) // in kilograms
  weightUnit String?  @default("kg")
  dimensions String? // JSON string: {length, width, height, unit}

  // Inventory management
  trackInventory  Boolean @default(true)
  minStockLevel   Int? // Reorder point
  maxStockLevel   Int? // Maximum stock level
  reorderQuantity Int? // Default reorder quantity

  // Product type and flags
  isActive     Boolean @default(true)
  isPerishable Boolean @default(false)

  // Relationships
  inventory          Inventory[]
  movements          InventoryMovement[]
  productSuppliers   ProductSupplier[]
  purchaseOrderItems PurchaseOrderItem[]

  // Audit fields
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime?

  // Performance indexes
  @@index([sku])
  @@index([barcode])
  @@index([categoryId])
  @@index([isActive])
  @@index([deletedAt])
  // @@fulltext([name, description]) // Full-text search on product name/description
  @@map("products")
}

// PRODUCT-SUPPLIER JUNCTION
// Many-to-many relationship: A product can have multiple suppliers,
// and a supplier can supply multiple products
// Stores supplier-specific data like their product code and lead time
model ProductSupplier {
  id String @id @default(cuid())

  productId String
  product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  supplierId String
  supplier   Supplier @relation(fields: [supplierId], references: [id], onDelete: Cascade)

  // Supplier-specific details
  supplierSku      String? // Supplier's product code
  supplierPrice    Int? // Price from this supplier
  leadTimeDays     Int? // Days to receive from this supplier
  minOrderQuantity Int? // Minimum order quantity

  // Preference
  isPreferred Boolean @default(false) // Primary supplier for this product
  isActive    Boolean @default(true)

  // Audit fields
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([productId, supplierId])
  @@index([productId])
  @@index([supplierId])
  @@index([isPreferred])
  @@map("product_suppliers")
}

// ============================================================================
// INVENTORY TRACKING
// ============================================================================

// INVENTORY
// Current stock levels per product per location
// This is the "current state" table - updated by movements
// CRITICAL: This should NEVER be updated directly - only through InventoryMovement transactions
model Inventory {
  id String @id @default(cuid())

  productId String
  product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  locationId String
  location   Location @relation(fields: [locationId], references: [id], onDelete: Cascade)

  // Stock levels
  quantityOnHand    Int @default(0) // Physical stock in location
  quantityReserved  Int @default(0) // Reserved for orders (future use)
  quantityAvailable Int @default(0) // Available = OnHand - Reserved

  // Reorder tracking
  lastRestocked DateTime?
  lastSold      DateTime?

  // Audit fields
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Business rule: One inventory record per product per location
  @@unique([productId, locationId])
  // Critical performance indexes
  @@index([productId]) // Find all locations for a product
  @@index([locationId]) // Find all products at a location
  @@index([quantityOnHand]) // Low stock queries
  @@index([productId, locationId]) // Composite for frequent lookups
  @@map("inventory")
}

// INVENTORY MOVEMENT
// Immutable audit log of ALL inventory changes
// Every quantity change MUST create a movement record
// This enables full traceability and historical analysis
model InventoryMovement {
  id String @id @default(cuid())

  productId String
  product   Product @relation(fields: [productId], references: [id], onDelete: Restrict)

  // Movement type determines business logic
  movementType MovementType

  // Location(s) involved
  // For most movements, use fromLocationId
  // For transfers, use both fromLocationId and toLocationId
  fromLocationId String?
  fromLocation   Location? @relation("MovementFromLocation", fields: [fromLocationId], references: [id], onDelete: Restrict)

  toLocationId String?
  toLocation   Location? @relation("MovementToLocation", fields: [toLocationId], references: [id], onDelete: Restrict)

  // Quantity (always positive, direction determined by movementType)
  quantity Int

  // Reference to source transaction (if applicable)
  purchaseOrderId String?
  purchaseOrder   PurchaseOrder? @relation(fields: [purchaseOrderId], references: [id], onDelete: SetNull)

  // Cost tracking (in cents)
  unitCost  Int? // Cost per unit at time of movement
  totalCost Int? // Total cost of movement (quantity * unitCost)

  // Documentation
  reference String? // External reference (PO number, invoice, etc.)
  notes     String?
  reason    String? // For adjustments: reason for the correction

  // Audit trail - WHO made the change (prepare for future auth)
  createdBy   String? // Future: User ID
  performedAt DateTime @default(now()) // When the movement occurred

  // Timestamps
  createdAt DateTime @default(now())

  // Critical indexes for performance and reporting
  @@index([productId]) // All movements for a product
  @@index([movementType]) // Query by movement type
  @@index([fromLocationId])
  @@index([toLocationId])
  @@index([performedAt]) // Time-series queries
  @@index([purchaseOrderId])
  @@index([productId, performedAt]) // Product history over time
  @@index([productId, movementType]) // Product movements by type
  @@map("inventory_movements")
}

enum MovementType {
  PURCHASE // Receiving from supplier (increases stock)
  SALE // Sold to customer (decreases stock)
  ADJUSTMENT // Manual correction (can increase or decrease)
  TRANSFER_OUT // Moved to another location (decreases stock at source)
  TRANSFER_IN // Received from another location (increases stock at destination)
  RETURN_IN // Customer return (increases stock)
  RETURN_OUT // Return to supplier (decreases stock)
  DAMAGE // Damaged/lost inventory (decreases stock)
  PRODUCTION_IN // Created via manufacturing/assembly (increases stock)
  PRODUCTION_OUT // Consumed in manufacturing (decreases stock)
}

// ============================================================================
// PURCHASE ORDERS (Receiving Inventory)
// ============================================================================

// PURCHASE ORDER
// Represents an order placed with a supplier
// Links to inventory movements when received
model PurchaseOrder {
  id String @id @default(cuid())

  orderNumber String @unique // Business-friendly PO number

  supplierId String
  supplier   Supplier @relation(fields: [supplierId], references: [id], onDelete: Restrict)

  locationId String // Which location will receive the goods
  location   Location @relation(fields: [locationId], references: [id], onDelete: Restrict)

  // Status tracking
  status POStatus @default(DRAFT)

  // Dates
  orderDate    DateTime  @default(now())
  expectedDate DateTime?
  receivedDate DateTime?

  // Financials
  subtotal Int @default(0)
  tax      Int @default(0)
  shipping Int @default(0)
  total    Int @default(0)

  // Documentation
  notes String?
  terms String?

  // Relationships
  items     PurchaseOrderItem[]
  movements InventoryMovement[] // Links to movements when received

  // Audit fields
  createdBy String? // Future: User ID
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([orderNumber])
  @@index([supplierId])
  @@index([locationId])
  @@index([status])
  @@index([orderDate])
  @@index([expectedDate])
  @@map("purchase_orders")
}

enum POStatus {
  DRAFT // Being created
  SUBMITTED // Sent to supplier
  CONFIRMED // Supplier confirmed
  PARTIAL // Partially received
  RECEIVED // Fully received
  CANCELLED // Cancelled
}

// PURCHASE ORDER ITEM
// Line items in a purchase order
model PurchaseOrderItem {
  id String @id @default(cuid())

  purchaseOrderId String
  purchaseOrder   PurchaseOrder @relation(fields: [purchaseOrderId], references: [id], onDelete: Cascade)

  productId String
  product   Product @relation(fields: [productId], references: [id], onDelete: Restrict)

  // Quantities
  quantityOrdered  Int
  quantityReceived Int @default(0)

  // Pricing
  unitCost  Int
  totalCost Int // quantityOrdered * unitCost

  // Audit fields
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([purchaseOrderId])
  @@index([productId])
  @@map("purchase_order_items")
}
